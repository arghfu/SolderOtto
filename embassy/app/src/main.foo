// #![no_std]
// #![no_main]
//
// mod solderotto;
//
// use defmt::*;
// use cortex_m_rt::entry;
// use embassy_executor::Spawner;
// use embassy_executor::{Executor, InterruptExecutor};
// use embassy_stm32::interrupt;
// use embassy_stm32::interrupt::{InterruptExt, Priority};
// use embassy_time::{Instant, Timer};
// use static_cell::StaticCell;
// use embassy_stm32::exti::ExtiInput;
// use embassy_stm32::gpio::{AnyPin, Level, Output, OutputOpenDrain, Pin, Pull, Speed};
// use embassy_stm32::adc::{Adc, AdcChannel, AnyAdcChannel, SampleTime, VrefInt};
// use embassy_stm32::{Config};
//
//
//
// use {defmt_rtt as _, panic_probe as _};
// use solderotto::handle::Handle;
//
// #[embassy_executor::task]
// async fn zero_crossing() {
//
//     loop {
//         Timer::after_micros(40).await;
//
//     }
// }
//
// #[embassy_executor::task]
// async fn buzz(pin: AnyPin) {
//     let mut buzzer = Output::new(pin, Level::Low, Speed::Low);
//
//     loop {
//         Timer::after_secs(20).await;
//         buzzer.set_high();
//         Timer::after_secs(1).await;
//         buzzer.set_low();
//     }
// }
//
// static EXECUTOR_HIGH: InterruptExecutor = InterruptExecutor::new();
// static EXECUTOR_MED: InterruptExecutor = InterruptExecutor::new();
//
// #[interrupt]
// unsafe fn UART4() {
//     EXECUTOR_HIGH.on_interrupt()
// }
//
// #[interrupt]
// unsafe fn TIM2() {
//     EXECUTOR_MED.on_interrupt()
// }
//
// #[entry]
// fn main() -> ! {
//     info!("Hello, World!");
//
//     let mut config = Config::default();
//     {
//         use embassy_stm32::rcc::*;
//         config.rcc.hsi = true;
//         config.rcc.pll = Some(Pll {
//             source: PllSource::HSI,
//             prediv: PllPreDiv::DIV1,
//             mul: PllMul::MUL20,
//             // Main system clock at 160 MHz
//             divr: Some(PllRDiv::DIV2),
//             divq: Some(PllQDiv::DIV8),
//             divp: Some(PllPDiv::DIV2),
//         });
//         config.rcc.mux.adc12sel = mux::Adcsel::SYS;
//         config.rcc.sys = Sysclk::PLL1_R;
//     }
//
//     let mut p = embassy_stm32::init(config);
//
//     let mut led = OutputOpenDrain::new(p.PC12, Level::High, Speed::Low);
//
//     let mut zcd = ExtiInput::new(p.PB0, p.EXTI0, Pull::None);
//
//     let mut adc = Adc::new(p.ADC1);
//
//     interrupt::UART4.set_priority(Priority::P6);
//     let spawner = EXECUTOR_HIGH.start(interrupt::UART4);
//     unwrap!(spawner.spawn(zero_crossing()));
//
//
//     // Medium-priority executor: UART5, priority level 7
//     interrupt::TIM2.set_priority(Priority::P7);
//     let spawner = EXECUTOR_MED.start(interrupt::TIM2);
//     spawner.spawn(buzz(p.PB6.degrade())).unwrap();
//
//
//
//     let foobar  = adc.blocking_read(&mut adc.enable_vrefint().degrade_adc());
//     info!("foobar: {}", foobar);
//     loop {
//
//     }
// }
//


// #![no_std]
// #![no_main]
// 
// use defmt::{info, unwrap};
// use embassy_executor::Spawner;
// use embassy_stm32::flash::{Blocking, Flash};
// use {defmt_rtt as _, panic_probe as _};
// 
// 
// #[embassy_executor::main]
// async fn main(_spawner: Spawner) {
//     let p = embassy_stm32::init(Default::default());
// 
//     // info!("Hello Flash!");
//     // 
//     // // Once can also call `into_regions()` to get access to NorFlash implementations
//     // // for each of the unique characteristics.
//     let mut f = Flash::new_blocking(p.FLASH);
//     // 
//     // // Sector 5
//     test_flash(&mut f, 128 * 1024, 4 * 1024);
// 
//     test_flash(&mut f, (256) * 1024, 128 * 1024);
//     
//     test_flash(&mut f, (384) * 1024, 128 * 1024);
//     loop {
//         cortex_m::asm::nop();
//     }
// }
// 
// fn test_flash(f: &mut Flash<'_, Blocking>, offset: u32, size: u32) {
//     info!("Testing offset: {=u32:#X}, size: {=u32:#X}", offset, size);
// 
//     info!("Reading...");
//     let mut buf = [0u8; 32];
//     unwrap!(f.blocking_read(offset, &mut buf));
//     info!("Read: {=[u8]:x}", buf);
// 
//     info!("Erasing...");
//     unwrap!(f.blocking_erase(offset, offset + size));
// 
//     info!("Reading...");
//     let mut buf = [0u8; 32];
//     unwrap!(f.blocking_read(offset, &mut buf));
//     info!("Read after erase: {=[u8]:x}", buf);
//     
// 
//     info!("Writing...");
//     unwrap!(f.blocking_write(
//         offset,
//         &[
//             1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
//             30, 31, 32
//         ]
//     ));
// 
//     info!("Reading...");
//     let mut buf = [0u8; 32];
//     unwrap!(f.blocking_read(offset, &mut buf));
//     info!("Read: {=[u8]:x}", buf);
//     assert_eq!(
//         &buf[..],
//         &[
//             1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
//             30, 31, 32
//         ]
//     );
// }


#![no_std]
#![no_main]

use core::cell::RefCell;

#[cfg(feature = "defmt")]
use defmt_rtt::*;
use embassy_boot_stm32::{AlignedBuffer, BlockingFirmwareState, FirmwareUpdaterConfig};
use embassy_executor::Spawner;
use embassy_stm32::flash::{Flash, WRITE_SIZE};
use embassy_stm32::usb::{self, Driver};
use embassy_stm32::{bind_interrupts, peripherals};
use embassy_sync::blocking_mutex::Mutex;
use embassy_time::Duration;
use embassy_usb::Builder;
use embassy_usb_dfu::consts::DfuAttributes;
use embassy_usb_dfu::{usb_dfu, Control, ResetImmediate};
use panic_reset as _;

bind_interrupts!(struct Irqs {
    USB_LP => usb::InterruptHandler<peripherals::USB>;
});

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let mut config = embassy_stm32::Config::default();
    
    let p = embassy_stm32::init(config);
    let flash = Flash::new_blocking(p.FLASH);
    let flash = Mutex::new(RefCell::new(flash));

    let config = FirmwareUpdaterConfig::from_linkerfile_blocking(&flash, &flash);
    let mut magic = AlignedBuffer([0; WRITE_SIZE]);
    let mut firmware_state = BlockingFirmwareState::from_config(config, &mut magic.0);
    firmware_state.mark_booted().expect("Failed to mark booted");

    let driver = Driver::new(p.USB, Irqs, p.PA12, p.PA11);
    let mut config = embassy_usb::Config::new(0xc0de, 0xcafe);
    config.manufacturer = Some("Embassy");
    config.product = Some("USB-DFU Runtime example");
    config.serial_number = Some("1235678");

    let mut config_descriptor = [0; 256];
    let mut bos_descriptor = [0; 256];
    let mut control_buf = [0; 64];
    let mut state = Control::new(firmware_state, DfuAttributes::CAN_DOWNLOAD);
    let mut builder = Builder::new(
        driver,
        config,
        &mut config_descriptor,
        &mut bos_descriptor,
        &mut [],
        &mut control_buf,
    );

    usb_dfu::<_, _, ResetImmediate>(&mut builder, &mut state, Duration::from_millis(2500));

    let mut dev = builder.build();
    dev.run().await
}

